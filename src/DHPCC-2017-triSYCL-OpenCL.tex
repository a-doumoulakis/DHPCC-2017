\documentclass[sigplan, review]{acmart}

\usepackage{booktabs} % For formal tables


% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
%\acmDOI{10.475/123_4}

% ISBN
%\acmISBN{123-4567-24-567/08/06}

%Conference
\acmConference[DHPCC'2017]{Distributed \& Heterogeneous Programming in
  C/C++ Workshop 2017}{May 2017}{Toronto, Canada}

\acmMonth{5}
\acmYear{2017}

%\acmPrice{15.00}

%\acmBadgeL[http://ctuning.org/ae/ppopp2016.html]{ae-logo}
%\acmBadgeR[http://ctuning.org/ae/ppopp2016.html]{ae-logo}


\begin{document}

\title{SYCL C++17 and OpenCL interoperability with triSYCL}

\author{Anastasios Doumoulakis}
\email{anastasi@xilinx.com}

\author{Ronan Keryell}
\email{Ronan.Keryell@xilinx.com}

\author{Kenneth O'Brien}
\email{kennetho@xilinx.com}

\affiliation{%
  \institution{Xilinx Research}
  \streetaddress{2020 Bianconi Avenue}
  \city{Dublin}
  \country{Ireland}
  \postcode{D24 T683}
}


\begin{abstract}
Heterogeneous computing 
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>  
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

% We no longer use \terms command
%\terms{Theory}

\keywords{C++17, SYCL, OpenCL}


\maketitle

\section{Introduction}
\label{sec:introduction}

Computing architectures nowadays are huge multi-processor
system-on-chips with different kind of processors, GPU, configurable
specific accelerators (video CODEC...), reconfigurable programmable
logic (FPGA), various hierarchies of memory and memory interfaces,
configurable IO and network support, security support, power control,
etc. High-performance applications may use a hierarchy of such system
up to fill up a full-scale data-center.

So the programmer is facing nowadays a fractal architecture, demanding
also more and more control for power efficiency. This tends to require
a dense fractal set of skills and tools.

SYCL \cite{C++:P00236R0:SYCL} is a new open standard from Khronos
Group aiming at solving some of the programming issues related to
heterogeneous computing.  This pure C++17 domain-specific embedded
language allows the programmer to write single-source C++17 host code
with accelerated code expressed as functors. The data accesses are
described with accessor objects that implicitly define a task graph
that can be asynchronously scheduled on a distributed-memory system
including several CPU and accelerators.

This programming model is quite generic but provides also an
interoperability mode with the OpenCL realm, another standard from
Khronos Group aimed at heterogeneous computing with a C host API and
separate language for the kernels (C, C++, SPIR and SPIR-V).  This
allows a SYCL C++ application to recycle existing OpenCL kernels into
a higher level C++ programming model, relieving the programmer from
explicitly defining the memory transfers.

In this article we present in Section~\ref{sec:sycl} the SYCL
standard, then in Section~\ref{sec:sycl-opencl-inter} to finish in
Section~\ref{sec:exper-with-opencl} with some experiments with the
triSYCL open source implementation of the SYCL standard.

\section{SYCL}
\label{sec:sycl}


\section{SYCL and OpenCL interoperability mode}
\label{sec:sycl-opencl-inter}


\section{Experimenting with OpenCL interoperability mode of SYCL}
\label{sec:exper-with-opencl}

\subsection{Example from Anastasios}
\label{sec:example-from-anast}


\url{https://github.com/archonSTB/triSYCLExample}

\subsection{Example from Ken}
\label{sec:example-from-ken}


\section{Related work}
\label{sec:related-work}


\section{Conclusion}
\label{sec:conclusion}

Heterogeneous computing in embedded and high-performance computing is
here to stay because of physical constrains. This puts the pressure on
the programmers to integrate a full system across the various
accelerators. The SYCL standard C++ DSeL allows a single-source
approach for both host and accelerators parts in type-safe way to
simplify the process while interoperable with the ubiquitous C/C++
world. The SYCL runtime provides an implicit task graph managing
asynchronicity and data transfers across the various memory spaces.

Besides this very general programming model, SYCL provides also
interoperability with the OpenCL world, allowing to launch existing
OpenCL kernels while taking advantage of the SYCL framework. While no
longer a single-source programming model in that case, it still
provides the implicit task graph with buffers and accessors, relieving
the programmer to manage explicitly the buffers and memory transfers
between the host and the devices.

This interoperability mode in the SYCL standard has some value by
itself even if this role was not envisioned at the first place. It
allows to use SYCL as a high-level framework to run OpenCL kernels
using a pure C++ approach without the need of a device compiler.

The open-source triSYCL implementation \cite{triSYCL} we are working
on provides also this interoperability mode, as shown with the
application samples presented in this article and the performance
comparisons with other frameworks.



\bibliographystyle{ACM-Reference-Format}
\bibliography{biblio}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-auto-untabify: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "american"
%%% End:
